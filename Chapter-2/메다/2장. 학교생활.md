# 엘강오 챕터2

## 2.1. 가능하면 적게 캡슐화 하세요

- 객체 하나당 4개 이하의 객체를 캡슐화
- 객체란 고수준의 행동을 위한 객체들의 집합
    - 캡슐화된 객체들은 객체의 식별자 역할
- 코틀린에서 data class를 사용

## 2.2. 최소한 뭔가는 캡슐화하세요

- 객체 하나당 1개 이상의  객체를 캡슐화
    - 객체 자신을 식별할 수 있도록
- 생성자로만 인스턴스를 생성하라

## 2.3.  항상 인터페이스를 사용하세요

- 결합도를 약화시키고 유지보수성을 높임
- 다른 객체를 수정하지 않고 해당 객체를 수정가능
- 퍼블릭 메서드는 반드시 인터페이스의 구현체여야 함

## 2.4 메서드 이름을 신중하게 선택하세요

- 2.4.1. 빌더의 이름은 명사로 짓는다
    - 뭔가를 만들어 새로운 객체를 반환하는 메서드
    - parsedCell와 같이 형용사를 덧붙여 지어도 좋다
    - 브라우니를 요리해 주세요 x 브라우니 주세요 o
        - 요리하든, 만든걸 꺼내주든 방법에 관심x
        - 무엇을 만들지만 요청하고 어떻게 만들지는 객체가 결정하게 해야 함
- 2.4.2. 조정자의 이름은 동사로 짓는다
    - 실세계 엔티티를 수정하며 반환값이 없는 메서드
    - quicklyPrint와 같이 부사를 덧붙여 지어도 좋다
    - 음악을 틀고 볼륨 상태를 말해주세요 x
    - 빌더와 조정자의 역할을 섞으면 안된다
        - 조작하는 동시에 반환하거나 빌드하는 동시에 조작하지 마라
    - 빌더 패턴을 사용하지 마세요
- 2.4.3 빌더와 조정자를 혼합
    - 하지 마세요
    - OOP의 전체 목적은 개념을 고립시키 복잡성을 낮추는 것
- 2.4.4 Boolean 값을 결과로 반환하는 경우
    - 반환값이 있지만 예외적으로 형용사로 이름을 짓는다
    - is 접두사를 붙이지 않는다
- 2.4 섹션 정리
    - 값을 반환하는 메서드인 빌더는 명사로 짓는다
        - 단Boolean값을 반환하면 형용사를 짓는다
    - 값을 반환하지 않는 조정자는 동사로 짓는다

## 2.5 퍼블릭 상수를 사용하지 마세요

- 코드 중복을 해결하기 위해 퍼블릭 상수를 쓰지 마세요
    - 결합도가 추가되고 응집도가 낮아지기 때문
- 2.5.1 결합도 추가
    - 퍼블릭 상수를 수정하면 퍼블릭 상수를 사용하는 여러 클래스들의 동작을 예측할 수 없음
    - 상수가 복잡할수록 문제는 더욱 심각해짐
- 2.5.2 응집도 저하
    - 상수를 사용하는 객체가 상수의 목적을 명확하게 만드는 코드를 추가해야 하므로 객체 자신의 문제를 해결하는데 덜 집중함
- 퍼블릭 상수의 대안
    - 기능을 공유할 수 있도록 새로운 클래스를 만들어야 함
        - 데이터가 아니라 기능을 공유해야함에 유의
    - 상수를 사용하는 기능을 클래스로 만들어 고립시킬것
    - 퍼블릭 상수와 결합하지 말고 클래스와 계약을 할것
    - 수백개의 상수 문자열 대신 수백개의 마이크로 클래스를 만들어라
- 열거형도 사용하지 말것

## 2.6 불변 객체로 만드세요

- 객체율 생성한 후 객체의 상태를 변겅할 수 없게 할 것
- 가변 객체를 엄격하게 금지할것, 어떤 클래스도 가변으로 만들지 말것
- 지연 로딩을 사용하여 객체를 한번만 초기화하고 불변으로 만들 것
- 2.6.1 식별자 가변성
    - 불변 객체는 상태가 변경되지 않으므로 객체를 저장하는 식별자 변경 문제가 발생하지 않음
- 2.6.2 실패 원자성
    - 객체가 견고하거나 실패하거나 둘 중 하나만 가능
    - 불변 객체는 객체 내부의 값이 절반만 수정되는 버그의 발생 가능성 원천 차단
- 2.6.3 시간적 결합
    - 가변 객체는 메서드의 실행 순서를 지켜줘야 함
    - 불변 객체로 객체를 완전한 상태로 견고하게 초기화 해야 함
- 2.6.4 부수 효과의 제거
    - 불변객체는 객체 내부의 값을 실수로 외부에서 변화시키는 사이드 이팩트의 가능성 원천 차단
- 2.6.5 NULL 참조 없애기
    - NULL 을 참조하면 객체가 유효한지 체크하며 유지보수성이 저하됨
    - 초기화되지 않은 프로퍼티를 사용하는건 새 클래스를 추가하는게 귀찮아서 이므로 지양할것
    - 모든 객체를 불변으로 민들면 객채 내부에 NULL을 참조하는 프로퍼티가 없음
- 2.6.6 스레드 안정성
    - 웉번 객체는 실행 시섬에 상태들 수정할 수 없게 금지함으로써 동시성 문제를 해결
    - 아무리 많은 스레드가 객체에 접근해도. 상태를 수정할 수 없어서 안전함.
- 2.6.7 더 작고 단순한 객체
    - 불변성은 클래스를 더 깔끔하고 더 짧게 만들게 함
    - 객체가 더 단순해질수록 옹집도는 더 높아지고, 유지보수는 더 쉬워짐
    - Java에서 클래스의 최대 크기는 주석과 공백을 포함해서 250 줄 이내로 만들것

## 2.7 문서화 대신 테스트를 작성하세요

- 훌륭하고 유지보수 가능한 클래스는 문서화가 필요하지 않다
- 좋은 클래스는 목적이 명확하고 우아한 설계를 가진다
- 문서화 대신 코드를 깔끔하게 만들어라
- 단위 테스트 자체가 문서화이다.
    - 올바르게 작성된 단위 테스트는 클래스를 이해하는데 큰 도움을 줌
    - 단위 테스트는 클래스의 사용방법을 직관적으로 보여줌
- 메인 코드만큼 단위 테스트에도 관심을 기울일것

## 2.8 모의 객체(Mock) 대신 페이크 객체(Fake)를 사용하세요

- 인터페이스에 대한 모의 객체를 생성하여 테스트 하지 말것
    - 모킹은 가정을 사실로 전환하므로 유지보수를 어렵게 한다.
    - 객체 내부의 블랙박스와 같은 구현을 모의 객체가 미리 알고있다는 가정을 전제로함
        - 객체의 구현이 변경되면 모킹을 사용한 테스트는 실페하게 됨
- 인터페이스 내부에 페이크 객체를 제공할것
    - 페이크 클래스는 스마트하고 강력할것
    - 페이크 클래스가 테스트를 올바르게 지원하도록 할것
    - 페이크 클래스는 인터페이스의 사용자 관점에서 설계에 더 깊은 고민을 하도록 해줌

## 2.9 인터페이스를 짧게 유지하고 스마트를 사용하세요

- 인터페이스 내부에 스마트 클래스를 두고 공통적인 작업을 수행하는 많은 메서드를 포함하라
- Exchange 인터페이스를 구현하는 일을 번거롭게 만들 필요가 없음
- 코틀린에서는 companion object에 확장함수를 사용하면 될 것 같다… (아님 말고)

```kotlin
// 엘레강트 오브젝트 89p SMART 예제코드 코틀린 적용(?)

import Exchange.Smart.eurToUsd
import Exchange.Smart.toUsd

interface Exchange {
    fun rate(
        source: String,
        target: String,
    ): Float

    companion object Smart {
        fun Exchange.toUsd(source: String): Float = this.rate(source, "USD")

        fun Exchange.eurToUsd(): Float = this.toUsd("EUR")
    }
}

class NYSE : Exchange {
    override fun rate(
        source: String,
        target: String,
    ): Float =
        when {
            source == "KRW" && target == "USD" -> 0.000682f
            source == "EUR" && target == "USD" -> 1.083f
            else -> throw IllegalArgumentException("지원되지 않는 환율 조합입니다.")
        }
}

fun main() {
    val exchange = NYSE()
    println("KRW -> USD, 비율: ${exchange.eurToUsd()}, 10유로는 ${10 * exchange.eurToUsd()}달러")
    println("KRW -> USD, 비율: ${exchange.toUsd("KRW")}, 1000원은 ${1000 * exchange.toUsd("KRW")}달러")
}

```